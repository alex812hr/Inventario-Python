# -*- coding: utf-8 -*-
"""Stock_Almacen.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/178ePeusK1gSVM8N64IRHLjAqPmEHQMGl
"""

import pandas as pd
import io
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import files

# Configuraci√≥n est√©tica de los gr√°ficos
sns.set_theme(style="whitegrid")

class AuditoriaBCP:
    def __init__(self):
        self.df_stock = None
        self.df_salidas = None # This will store the sales data, potentially filtered
        self.reporte_operativo = {}

    def cargar_y_procesar(self):
        print("üìÅ POR FAVOR, SUBE TU ARCHIVO EXCEL (.xlsx)")
        uploaded = files.upload()

        if not uploaded: # Check if any file was uploaded
            print("‚ùå No se seleccion√≥ ning√∫n archivo. Por favor, sube tu archivo Excel para continuar.")
            return # Exit the method if no file was uploaded

        nombre_archivo = list(uploaded.keys())[0]

        # Cargar hojas
        ing = pd.read_excel(io.BytesIO(uploaded[nombre_archivo]), sheet_name='INGRESOS')
        sal = pd.read_excel(io.BytesIO(uploaded[nombre_archivo]), sheet_name='SALIDAS')

        # 1. Tratamiento de Fechas y Filtro EST1
        sal['FECHA_C'] = pd.to_datetime(sal['FECHA_C'])
        sal['FECHA2'] = pd.to_datetime(sal['FECHA2'])

        # Calculamos d√≠as solo para atendidos (EST1 == 1)
        sal['DIAS_ATENCION'] = (sal['FECHA2'] - sal['FECHA_C']).dt.days

        # --- APLICAR FILTRO: EXCLUIR N_COMPRA = 801 DESDE EL INICIO ---
        # Filtramos sal (salidas)
        sal_filtered = sal[sal['N_COMPRA'] != 801].copy()
        self.df_salidas = sal_filtered # Store the filtered sales for other methods

        # Filtramos ing (ingresos) para ser consistente si N_COMPRA 801 existiera aqu√≠
        ing_filtered = ing[ing['N_COMPRA'] != 801].copy()


        # 2. L√≥gica de Trazabilidad (ITEM + N_COMPRA)
        # Solo descontamos lo atendido (EST1 == 1) usando el df_salidas_filtered
        df_sal_atendidas = self.df_salidas[self.df_salidas['EST1'] == 1].groupby(['ITEM', 'N_COMPRA'])['CANT_AG'].sum().reset_index()
        df_ing_total = ing_filtered.groupby(['ITEM', 'PRODUCTO', 'N_COMPRA'])['CANT_INGRESADA'].sum().reset_index()


        # Unir para stock final
        self.df_stock = pd.merge(df_ing_total, df_sal_atendidas, on=['ITEM', 'N_COMPRA'], how='left').fillna(0)
        self.df_stock['STOCK_ACTUAL'] = self.df_stock['CANT_INGRESADA'] - self.df_stock['CANT_AG']

        # 3. Calcular m√©tricas de tiempo con los datos filtrados
        # Solo consideramos d√≠as de atenci√≥n positivos para 'oc_rapidas' para evitar errores de registro.
        oc_rapidas_data = self.df_salidas[
            (self.df_salidas['EST1'] == 1) & (self.df_salidas['DIAS_ATENCION'] > 0)
        ].groupby('N_COMPRA')['DIAS_ATENCION'].mean().sort_values()

        if not oc_rapidas_data.empty:
            self.reporte_operativo['mejor_oc'] = oc_rapidas_data.index[0]
            self.reporte_operativo['mejor_tiempo'] = oc_rapidas_data.values[0]
        else:
            self.reporte_operativo['mejor_oc'] = 'N/A'
            self.reporte_operativo['mejor_tiempo'] = 0.0 # Or None, depending on desired representation

        # Promedio general de atenci√≥n (de los atendidos y filtrados)
        self.reporte_operativo['promedio_atencion'] = self.df_salidas[self.df_salidas['EST1'] == 1]['DIAS_ATENCION'].mean()


    def generar_visualizaciones(self):
        fig, axes = plt.subplots(1, 2, figsize=(16, 6))

        # Gr√°fico 1: Estado de Pedidos (Pie Chart)
        # Utiliza self.df_salidas que ya est√° filtrado
        estados = self.df_salidas['EST1'].value_counts()
        axes[0].pie(estados, labels=['Atendidos', 'Pendientes'], autopct='%1.1f%%', colors=['#4CAF50', '#FF5252'], startangle=140)
        axes[0].set_title('Eficiencia de Atenci√≥n (EST1) - Excluyendo OC #801')

        # Gr√°fico 2: Top 10 Productos con mayor Stock
        # Utiliza self.df_stock que ya est√° filtrado
        top_stock = self.df_stock.sort_values('STOCK_ACTUAL', ascending=False).head(10)
        # Correcting the FutureWarning: assign y to hue and set legend=False
        sns.barplot(ax=axes[1], x='STOCK_ACTUAL', y='PRODUCTO', data=top_stock, palette='viridis', hue='PRODUCTO', legend=False)
        axes[1].set_title('Top 10 Productos con Mayor Stock Disponible - Excluyendo OC #801')

        plt.tight_layout()
        plt.show()

    def exportar_excel(self):
        nombre_file = 'REPORTE_INTELIGENTE_BCP_FILTRADO.xlsx' # New name to indicate it's filtered
        # Usamos ExcelWriter para poder guardar varias hojas si quisi√©ramos
        with pd.ExcelWriter(nombre_file) as writer:
            self.df_stock.to_excel(writer, sheet_name='STOCK_FINAL', index=False)
            # Tambi√©n exportamos las m√©tricas de tiempo
            # Asegurarse de usar self.df_salidas que ya est√° filtrado
            tiempos = self.df_salidas[self.df_salidas['EST1']==1][['N_COMPRA', 'PRODUCTO', 'DIAS_ATENCION']]
            tiempos.to_excel(writer, sheet_name='TIEMPOS_ATENCION', index=False)

        files.download(nombre_file)
        print(f"\n‚úÖ Excel generado y descargado: {nombre_file}")

# --- EJECUCI√ìN DEL SISTEMA ---
app = AuditoriaBCP()
app.cargar_y_procesar()

# Only proceed with printing and generating if app.df_stock was successfully populated
if app.df_stock is not None:
    print(f"\nüèÜ LA ORDEN DE COMPRA M√ÅS R√ÅPIDA (excluyendo OC #801): OC #{app.reporte_operativo['mejor_oc']}")
    print(f"‚è±Ô∏è Tiempo promedio de atenci√≥n (excluyendo OC #801): {app.reporte_operativo['promedio_atencion']:.2f} d√≠as")

    app.generar_visualizaciones()
    app.exportar_excel()
